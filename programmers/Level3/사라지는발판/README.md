# [프로그래머스 Level3] 사라지는 발판
- https://programmers.co.kr/learn/courses/30/lessons/92345?language=javascript
- 완전탐색문제다. A와B가 한번씩 번갈아가며 움직이고, 한번 움직이면 그 위치의 발판이 사라진다. 더이상 못 움직이는 상태가 되면 진다. 이 때 항상 지는 사람은 최대한 많이 움직이고, 항상 이기는 사람은 최대한 적게 움직여야 한다. 이 때 두 사람이 움직인 횟수의 합을 구하는 문제다.(항상 A가 먼저 시작한다)
  - 번갈아 가며 움직이기 때문에 재귀의 횟수를 기준으로 짝수는 A,홀수는 B의 턴이 된다.
  - 재귀함수는 마지막에 진사람의 재귀의 횟수(두 사람이 움직인 횟수의 합)를 반환한다.
    - 반환값이 짝수라면 A가 진것이고, 홀수라면 B가 진 것이다.
  - 두 가지 값(패배시 움직인 횟수, 승리시 움직인 횟수)을 갱신해야 한다. 
    - 만약 A의 턴(count가 짝수)이라면, A의 패배(재귀의 반환값이 짝수)시 최댓값을 선택해 갱신해야 한다. 반대로 A의 승리(재귀의 반환값이 홀수)시 최솟값을 선택해 갱신해야 한다.
    - 만약 B의 턴도 마찬가지로 B의 턴(count가 홀수)이라면, B의 패배(재귀의 반환값이 홀수)시 최댓값을 선택해 갱신해야 한다. 반대로 A의 승리(재귀의 반환값이 짝수)시 최솟값을 선택해 갱신해야 한다.
  - 4가지 방향을 모두 움직였는데도 최댓값과 최솟값 둘 다 갱신을 못했다면 현재턴에서 패배한 것으로 간주하고 반환한다.
  - 최댓값이나 최솟값중 갱신된것을 반환한다.
- 많이 복잡한 문제였고, 실제로 킬러문제로 출제된 문제다. 재귀에서 A와 B의 턴을 명확히 구분해서 생각하는 것이 중요했다. 
  - 처음엔 접근자체가 힘들어서 풀이를 참고해서 풀었다. 
  - 두번째에는 카카오에서 풀이를 해준대로 A와B의 턴을 구분 두가지 함수로 구분하여 풀었다.
  - 마지막 세번째는 아예 한가지 재귀함수로 처음부터 끝까지 고민해서 풀었다.
  - 다른 풀이들을 보면 A와B의 턴을 구분하고, 갱신도 각자 다르게 하는 것을 알 수 있었다. 특히 갱신의 조건이 이상한 풀이가 많았다.
  - 조건에서 생략된 부분이 있는데, 재귀의 반환에서 졌을때의 경우의 수보다 이겼을때의 경우의 수를 먼저 반환해야한다. 졌을때의 경우의 수를 먼저 반환하는 식으로 바꿔서 제출해보았는데 실제로 많은 케이스에서 실패가 떴다.
    - 간단히 말하자면 내가 항상 지는 경우의 수와 항상 이기는 경우의 수가 동시에 있다면 어느 것을 골라야 하는가? 예를들어 위로 움직였다면 항상 이기고 아래로 움직이면 항상 졌을 때 어디로 가야하는가? 좀 애매한 부분이 있다.