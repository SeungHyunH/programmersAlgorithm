# [프로그래머스 Level3] 외벽점검
- https://programmers.co.kr/learn/courses/30/lessons/43164
- 순열 및 알고리즘구현력을 요구하는 문제였다. 
  1. Weak의 탐색순서를 구한다.
      - 예를들어 [1, 5, 6, 10] 의 Weak가 있다고 했을 때 가능한 경우는 [1,5,6,10], [5,6,10,1], [6,10,1,5],[10,1,5,6] 이 있을 것이다.이를 시계에서 12시간형식->24시간 형식으로 바꿔서 1시->13시로 바꾸듯이 바꾸면 [1,5,6,10], [5,6,10,13], [6,10,13,17],[10,13,17,18] 의 경우의 수가 나온다.
      - 반시계방향의 경우 [1,5,6,10]을 반시계로 방문하면 [1,10,6,5]와 같은데 이 역시 역으로 뒤집어서 생각해보면 [5,6,10,13]과 방문순서가 같다고도 할 수 있다. 왜냐하면 5로 시작해서 1로 끝나는거나 1로시작해서 5로 끝나는 것이나 각 시간의 차이는 없기 때문이다. 
        - 1에서 반시계 : 1->10(+3), 10->6(+4), 6->5(+1) : 총8칸
        - 5에서 시계 : 5->6(+1), 6->10(+4), 10->13(+3) : 총 8칸
  2. dist의 순열을 구한다.
      - 이 문제의 경우 어떤지점에 어떤시간을 넣느냐에 따라 결과가 달라진다. 따라서 1명을 투입시켜서 만족시키는 경우, 2명을 투입시켜서 만족하는 경우 등 모든 순열을 구해서 순차적으로 만족시킬 때까지 찾으면 도니다.
      - dist의 최대길이는 8으로 순열로 진행해도 문제가 전혀 없다.
- 이 문제의 경우 순열을 묻는 문제기도했지만 주어진 graph를 단순화시키는 아이디어가 중요했다. 시계방향과 반시계방향이 결국 한 방향으로 처리해도 결과는 똑같다라는 것을 모르면 정말 어렵게 구현해야 하는 문제다. 각 방향대로 모든 경우의 수를 구하고, 모든 순열의 경우를 구해서 처리해야 하는데 최적화해서 시간도 최대한 짧게걸리게끔 만들어야하는 최악의 문제가 되었을 것이다.