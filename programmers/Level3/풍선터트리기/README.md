# [프로그래머스 Level3] 풍선 터트리기
- https://programmers.co.kr/learn/courses/30/lessons/68646
- Greedy문제다. 1개만 남을때까지 배열의 인접한 두 수중 더 작은것만 골랐을 때 가능한 경우의 수를 구하는 문제다. 유일하게 더 큰수를 고르는 경우는 딱 한번만 가능하다.
  - 이 문제는 전채 배열의 크기가 1,000,000 이므로 Greedy하게 풀어야 한다.
  - 현재 인덱스를 기준으로 0~현재인덱스 이전까지의 최솟값과 현재인덱스다음~배열끝까지의 최솟값, 현재값을 비교해 가능한 경우를 세면 된다.
  - 예를들어 [0 , 1, 2 , x , 3, 4 , 5 ... n] 까지의 배열이 있다고 가정했을 때 0~2 까지의 최솟값은 0, 3~n까지의 최솟값은 3이다.
    - 최종적으로 비교하게 되는 것은 2, x, 3 이 된다. 만약 x가 2와 3 두 수보다 크다면 어떤 경우라도 마지막까지 남을 수 없다.(더 큰 수를 고르는 것은 한번만 되기 때문)
    - 만약 최솟값을 고르는 과정에서 더 큰수를 고른다면 결국 마지막에 비교하는 것과 차이가 없다.(왜냐하면 count가 안되는 경우는 어차피 x가 두 최솟값보다 큰 경우이기 때문에 한쪽을 x보다 더 크게 남겼다고 하더라도 결국 나머지 한쪽 최솟값과도 비교해야 하기 때문) 따라서 이 경우는 고려하지 않아도 된다.
  - DP로 현재 인덱스를 제외한 왼쪽과 오른쪽의 최솟값을 갱신한 뒤 count를 센다.
- 생각보다 간단한 문제였다. 무조건 Greedy하게 접근해야 했고, DP로 접근하려면 최솟값을 비교해야한다는 생각이 드는순간 풀리는 문제였다.